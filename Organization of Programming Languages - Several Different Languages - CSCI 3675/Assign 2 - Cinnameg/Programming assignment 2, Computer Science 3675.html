<html>
<head>
  <title> Programming assignment 2, Computer Science 3675 </title>
  <link rel="stylesheet" href="../assignment.css" type="text/css">
</head>
<body>
<h2>
  Computer Science 3675<br>
  Section 001<br>
  Fall 2017<br>
  Programming Assignment 2
</h2>

<div align="center"><table>
  <tr>
    <td><b>Assigned:</b></td>
    <td>Wednesday, September 6</td>
  </tr>
  <tr>
    <td><b>Due:</b></td>
    <td>Wednesday, September 20, 11:59pm</td>
  </tr>
</table>
</div>


<h3>
  Purpose of this assignment 
  <hr class="heading">
</h3>

<p>This assignment gives you some experience in equational
programming and has you compare that to the imperative
programming that you used in assignment 1.
</p>

<h3>
  Overview of assignment 
  <hr class="heading">
</h3>

<p>For this assignment, you will write the inc, sum, and product functions
in an equational style instead of an imperative style.  You will also write
a power function.
</p>



<h3>
  Language
  <hr class="heading">
</h3>

<p>The language that you will use is Cinnameg.
There is material in the book on Cinnameg, and you can find
documentation 
<a href="http://www.cs.ecu.edu/~karl/cinnameg/9-2/lin/index.html">here</a>.
It is installed on xlogin.cs.ecu.edu
as /usr/local/bin/cmgc [a compiler] and /usr/local/bin/cmgr [an interpreter].
</p>

<p>Cinnameg is not a purely equational language, and it allows you to use
other styles.  For this assignment, stay within the equational subset
for writing the arithmetic and comparison functions.
Do not use loops, or anything that changes something once
you have already created it.  
Write in a declarative, equational style.
</p>

<p>You may use imperative aspects, such as Displayln, for
testing.
</p>



<h3>
  Representing nonnegative integers
  <hr class="heading">
</h3>

<p>A nonnegative integer can be represented in binary as 
a list of zeros and ones.
The most convenient way to do so is to put the least significant bit
first.  For example, the binary number 1101<sub>2</sub> (13 decimal) 
would be represented by the list [1,0,1,1].  
</p>

<p>Of course, list [1,0,1,1,0] also represents 13.  
Leading zeros in the standard representation
(as in 01101) are ignored, and they become trailing zeros in the
list representation.  Say that a list is <i>normalized</i> if
it does not end on 0.  So [1,0,1,1] is normalized, but
[1,0,1,1,0] is not.  Note that list [0] is not normalized, but
[&thinsp;] is. The empty list is a normalized representation of 0.
</p>



<h3>
  The assignment
  <hr class="heading">
</h3>

<p>Your assignment is to write the following functions
that work on lists as representations of binary numbers.
In all cases, <i>x</i> and <i>y</i> are lists of bits.
</p>

<ol>
  <li><p>
    inc(<i>x</i>) produces <i>x</i> + 1 (as a normalized list);
  </p></li>

  <li><p>
    sum(<i>x</i>, <i>y</i>) produces <i>x</i> + <i>y</i> (as a normalized list);
  </p></li>

  <li><p>
    product(<i>x</i>, <i>y</i>) produces <i>x</i> * <i>y</i> (as a normalized list);
  </p></li>

  <li><p>
    power(<i>x</i>, <i>y</i>) produces <i>x</i><sup><i>y</i></sup> (as a normalized list).
    Assume that <i>x</i> and <i>y</i> are not both 0.
  </p></li>

</ol>

<p>For example inc([1,1,0,1,0,1]) = [0,0,1,1,0,1] (43 + 1 = 44), and
sum([1,1], [1,1]) = [0,1,1] (3 + 3 = 6).  The result list of each function
should be normalized
even if the parameter lists are not.  For example,
inc([1,0,0,0]) = [0,1] (1 + 1 = 2).
</p>

<h3>
  Normalizing
</h3>

<p>You can handle normalization as follows. An example for inc should
suffice.  First, write an implementation of inc that does not worry
about normalizing its result.  You might call it incn, 
for inc-nonnormalizing.  Now define inc as follows.
<pre>
   Define inc x = normalize(incn x).
</pre>
Do the same for the other functions.
Function normalize is provided for you.
It just removes any trailing zeroes from the
list
</p>



<h3>
  Requirement
  <hr class="heading">
</h3>

<p>Cinnameg allows large integers.  But for this assigment,
you are expected to handle the algorithms 
directly using lists of bits.  It is not acceptable to 
convert from a list to an integer,
do the arithmetic on the integers, and then convert back to a list.
You are allowed to do arithmetic on small integers (say, any
integers less than 10).
</p>



<h3>
  Hints
  <hr class="heading">
</h3>

<p>Think about the number that each list represents.  Here are
some correspondences between lists and numbers.  In the left-hand
column, <i>x</i> stands for a list of bits.  In the right-hand
column, <i>x</i> stands for the corresponding number.
</p>

<div align="center">
<table>
  <tr>
    <th><u>List</u></th>
    <th>&emsp;</th>
    <th><u>Integer</u></th>
  </tr>

  <tr>
    <td>[&thinsp;]</td>
    <th>&emsp;</th>
    <td>0</td>
  </tr>

  <tr>
    <td>0::<i>x</i></td>
    <th>&emsp;</th>
    <td>2<i>x</i></td>
  </tr>

  <tr>
    <td>1::<i>x</i></td>
    <th>&emsp;</th>
    <td>2<i>x</i> + 1</td>
  </tr>
</table>
</div>

<p>For example, [0,1,1] = 0::[1,1].  List [1,1] stands for 3.
So [0,1,1] stands for 2(3) = 6.  Similarly, [1,0,0,1] = 1::[0,0,1].
List [0,0,1] stands for 4.  So [1,0,0,1] stands for 2(4) + 1 = 9.
</p>

<p>Think about your functions first in terms of arithmetic, then convert
to lists.  For example, you know that 
2<i>x</i> + (2<i>y</i> + 1) = 2(<i>x</i>+<i>y</i>) + 1.
Converting that to list notation, 
and writing sum(<i>a</i>,<i>b</i>) for <i>a</i> + <i>b</i>, yields
<blockquote>
  sumn(0::x, 1:y) = 1::sumn(x,y)
</blockquote>
Write a comment with each case telling the translation of that case
into arithmetic.  Please take a moment to ensure that the arithmetic
equation is true!
</p>


<h3>
  Writing and running the program
  <hr class="heading">
</h3>

<p>Write one package that defines and exports your definitions.
Do not export the helper functions that do not normalize their results.
See <a href="arithmetic.cmg" type="text/plain">arithmetic.cmg</a> 
for a skeleton of this module.  Use the skeleton as a starting point.
</p>

<p>Please include at least one Example for each function.  I have
written inc for you.  You will need to provide sum, product and power.
</p>

<p>To test your functions, use a separate module.  See
<a href="arithtest.cmg" type="text/plain">here</a> for a skeleton of 
a testing module.  Add tests.
</p>

<p>To compile arithmetic.cmg, use command
<pre>
  cmgc arithmetic
</pre>
if you want to have a listing written, or
<pre>
  cmgc -l arithmetic
</pre>
if you do not want a listing.
</p>

<p>The interpreter is called cmgr.
You will want to compile both arithmetic.cmg and
arithtest.cmg and then run arithtest. To do that
use commands
<pre>
  cmgc arithmetic
  cmgc arithtest
  cmgr -t arithtest
</pre>
Option -t of cmgr tells cmgr not to perform some optimizations
that would hide information from you if the program encounters
an error.
</p>


<h3>
  Submitting your work
  <hr class="heading">
</h3>

<p><b>Be sure to include your name in the program.</b>
When you are ready to turn in your work, use command
<pre>
   ~abrahamsonk/3675/bin/submit 2 arithmetic.cmg arithtest.cmg
</pre>
on xlogin.cs.ecu.edu.
Command
<pre>
   ~abrahamsonk/3675/bin/submit 2
</pre>
will tell you what you have submitted.
</p>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>
