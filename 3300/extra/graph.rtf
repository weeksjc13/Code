{\rtf1\ansi\ansicpg1252\cocoartf1344\cocoasubrtf720
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red100\green56\blue32;\red196\green26\blue22;
\red170\green13\blue145;\red28\green0\blue207;}
\margl1440\margr1440\vieww16500\viewh11900\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural

\f0\fs22 \cf2 \CocoaLigature0 // CSCI 3300\cf0 \
\cf2 // Assignment: 7\cf0 \
\cf2 // Author:     Ibook Eyoita\cf0 \
\cf2 // File:       graph.cpp\cf0 \
\cf2 // Tab stops:  Every 4 characters\cf0 \
\
\cf3 #include \cf4 "graph.h"\cf3 \
#include \cf4 "equiv.h"\cf3 \
#include \cf4 <cstdio>\cf3 \
#include \cf4 <iostream>\cf3 \
#include \cf4 <cstdlib>\cf3 \
\cf0 \
\cf5 using\cf0  \cf5 namespace\cf0  std;\
\
\cf5 void\cf0  addEdge(graph& g,\cf5 int\cf0  from, \cf5 int\cf0  to, \cf5 int\cf0  weight)\
\{\
	g.edgArray[g.numOfedges].u=from;\
	g.edgArray[g.numOfedges].v=to;\
	g.edgArray[g.numOfedges].weight=weight;\
	g.numOfedges++;\
\}\
\
\cf5 void\cf0  readGraph(graph &g)\
\{\
	\cf5 int\cf0  firstVert, secondVert;\
	\cf5 int\cf0  weight;\
	\cf5 int\cf0  i= \cf6 0\cf0 ;\
	\
	cin >> g.numOfvertices;\
	g.edgArray= \cf5 new\cf0  edge[maxEdges];\
	cin >> firstVert;\
	\cf5 while\cf0 (firstVert !=\cf6 0\cf0 )\
	\{\
		cin >> secondVert;\
		cin >> weight;\
		g.edgArray[i].u=firstVert;\
		g.edgArray[i].v=secondVert;\
		g.edgArray[i].weight=weight;\
		cin >> firstVert;\
		i++;\
	\}\
	g.numOfedges=i;\
\}\
\
\cf5 int\cf0  tracer=\cf6 0\cf0 ;\
\
\cf5 void\cf0  tracing (\cf5 int\cf0  argc, \cf5 char\cf0  *argv[])\
\{\
	\cf5 for\cf0 (\cf5 int\cf0  i=\cf6 1\cf0 ; i<argc; i++)\
	\{\
		\cf5 if\cf0 (strcmp(argv[i], \cf4 "-te"\cf0 ) == \cf6 0\cf0 )\
		\{\
			tracer = \cf6 1\cf0 ;\
		\}\
		\cf5 else\cf0  \cf5 if\cf0 (strcmp(argv[i], \cf4 "-tm"\cf0 ) == \cf6 0\cf0 )\
		\{\
			tracer=\cf6 2\cf0 ;\
		\}\
	\}\
\}\
\
\cf5 void\cf0  printGraph(\cf5 const\cf0  graph g)\
\{\
	\cf5 for\cf0 (\cf5 int\cf0  count= \cf6 0\cf0 ; count<g.numOfedges; count++)\
	\{\
		printf(\cf4 "%i %i %i\\n"\cf0 ,g.edgArray[count].u,g.edgArray[count].v, g.edgArray[count].weight);\
	\}\
\}\
\
\cf5 int\cf0  compareEdges(\cf5 const\cf0  edge* A, \cf5 const\cf0  edge* B)\
\{\
	\cf5 return\cf0  A->weight - B->weight;\
\}\
\
\cf5 int\cf0  totalWeight(graph &g)\
\{\
	\cf5 int\cf0  sum=\cf6 0\cf0 ;\
	\cf5 for\cf0 (\cf5 int\cf0  i=\cf6 0\cf0 ; i<g.numOfedges;i++)\
	\{\
		sum= sum+ g.edgArray[i].weight;\
	\}\
	\cf5 return\cf0  sum;\
\}\
\
\
graph Kruskal(graph &g)\
\{\
	Equiv e(g.numOfvertices);\
	graph mst;\
	mst.numOfedges=\cf6 0\cf0 ;\
	mst.edgArray= \cf5 new\cf0  edge[maxEdges];\
	qsort((\cf5 void\cf0 *) g.edgArray, g.numOfedges, \cf5 sizeof\cf0 (edge), (QSORT_COMPARE_TYPE) compareEdges);\
\
	\cf5 for\cf0 (\cf5 int\cf0  i=\cf6 0\cf0 ; i<g.numOfedges;i++)\
	\{\
		\cf5 if\cf0 (!together(e,g.edgArray[i].u,g.edgArray[i].v))\
		\{\
			addEdge(mst, g.edgArray[i].u, g.edgArray[i].v,g.edgArray[i].weight);\
			combine(e, g.edgArray[i].u, g.edgArray[i].v);\
		\}\
	\}\
	\cf5 return\cf0  mst;\
\}\
\
}